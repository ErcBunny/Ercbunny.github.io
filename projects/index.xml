<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Projects on Ryan&#39;s Page</title>
        <link>https://ercbunny.github.io/projects/</link>
        <description>Recent content in Projects on Ryan&#39;s Page</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 09 Apr 2022 12:00:00 +0800</lastBuildDate><atom:link href="https://ercbunny.github.io/projects/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>OmniHex</title>
        <link>https://ercbunny.github.io/projects/220409-omnihex/</link>
        <pubDate>Sat, 09 Apr 2022 12:00:00 +0800</pubDate>
        
        <guid>https://ercbunny.github.io/projects/220409-omnihex/</guid>
        <description>&lt;img src="https://ercbunny.github.io/projects/220409-omnihex/cover.png" alt="Featured image of post OmniHex" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;links--downloads&#34;&gt;LINKS &amp;amp; DOWNLOADS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/Project%20Experience.pptx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Presentation of Early Work (English)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/omnihex.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Research Proposal (Chinese)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/%e4%b8%ad%e6%9c%9f%e6%8a%a5%e5%91%8a.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Midterm Summary (Chinese)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/wide.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Closing Presentation (Chinese)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://1drv.ms/b/s!AtUoQjeuHMpihMpIooJgC1C_nQjvbw?e=b5tRRc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Thesis (Chinese)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;video-demo&#34;&gt;VIDEO DEMO&lt;/h2&gt;






    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1ov4y1g7R6&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://ercbunny.github.io/projects/220409-omnihex/numsim.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;img src=&#34;https://ercbunny.github.io/projects/220409-omnihex/gzsim.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;img src=&#34;https://ercbunny.github.io/projects/220409-omnihex/real.png&#34;
	width=&#34;1100&#34;
	height=&#34;1008&#34;
	srcset=&#34;https://ercbunny.github.io/projects/220409-omnihex/real_hu8060b16c994461fdc70f2d342878ea98_2435923_480x0_resize_box_3.png 480w, https://ercbunny.github.io/projects/220409-omnihex/real_hu8060b16c994461fdc70f2d342878ea98_2435923_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;109&#34;
		data-flex-basis=&#34;261px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dev-milestones&#34;&gt;Dev Milestones&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Upgrade to ROS2: 100%&lt;/li&gt;
&lt;li&gt;PID and Newton-Euler Dynamics in SITL: 100%&lt;/li&gt;
&lt;li&gt;Real hardware drivers and maiden flight: 100%&lt;/li&gt;
&lt;li&gt;Controller architecture and design: 100%&lt;/li&gt;
&lt;li&gt;Formulate MPC solver using acados: 100%&lt;/li&gt;
&lt;li&gt;Test MPC solver in Python: 100%&lt;/li&gt;
&lt;li&gt;L1-MPC python simulation: 100%&lt;/li&gt;
&lt;li&gt;ROS L1-MPC node: 100%&lt;/li&gt;
&lt;li&gt;Track trajectories and collect data: 100%&lt;/li&gt;
&lt;li&gt;Thesis writing: 100%&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Far from perfect, but done for now (May29, 2022)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;environment-setup&#34;&gt;Environment Setup&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Ubuntu 20.04 LTS&lt;/code&gt; with &lt;code&gt;ROS2 foxy&lt;/code&gt; and &lt;code&gt;ROS1 noetic&lt;/code&gt; (since vrpn-client-ros is only available for ROS1).&lt;/li&gt;
&lt;li&gt;Install ROS2 &lt;a class=&#34;link&#34; href=&#34;https://docs.ros.org/en/foxy/Installation/Ubuntu-Install-Debians.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;via debian&lt;/a&gt; and &lt;a class=&#34;link&#34; href=&#34;https://docs.px4.io/master/en/ros/ros2_comm.html#install-ros-2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;additional tools&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Install Fast-RTPS-Gen using source code.
&lt;ul&gt;
&lt;li&gt;Install &lt;a class=&#34;link&#34; href=&#34;https://gradle.org/install/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gradle v6.3&lt;/a&gt; through &lt;a class=&#34;link&#34; href=&#34;https://sdkman.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;sdkman&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Use Gradle to build and install Fast-RTPS-Gen.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone --recursive https://github.com/eProsima/Fast-DDS-Gen.git -b v1.0.4 ~/Fast-RTPS-Gen \
    &amp;amp;&amp;amp; cd ~/Fast-RTPS-Gen \
    &amp;amp;&amp;amp; gradle assemble \
    &amp;amp;&amp;amp; sudo env &amp;#34;PATH=$PATH&amp;#34; gradle install
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Install dependencies for PX4: &lt;code&gt;PX4-Autopilot/Tools/setup/ubuntu.sh&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Install officially provided ROS2 plug-ins for Gazebo: &lt;code&gt;sudo apt install ros-foxy-gazebo-ros-pkgs&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Install &lt;a class=&#34;link&#34; href=&#34;http://qgroundcontrol.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;QgroundControl&lt;/a&gt; ground station.&lt;/li&gt;
&lt;li&gt;Install packages for optitrack: &lt;code&gt;sudo apt install ros-foxy-ros1-bridge ros-noetic-vrpn ros-noetic-vrpn-client-ros&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vrpn-client-ros&lt;/code&gt; publishes the built in message type &lt;code&gt;geometry-msgs&lt;/code&gt;, it is OK to use debian release of &lt;code&gt;ros1-bridge&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Building &lt;code&gt;ros1-bridge&lt;/code&gt; form source enables extra support for custom message and service types but has conflicts with &lt;code&gt;ros-foxy-controller-manager-msgs&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Install mavros for data visualization: &lt;code&gt;sudo apt install ros-noetic-mavros* ros-noetic-mavlink&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Dynamixel-sdk &lt;code&gt;ros-foxy-dynamixel-*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;build_acados.sh&lt;/code&gt; to set up the mpc code generation tool.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;
&lt;h3 id=&#34;l1-mpc&#34;&gt;L1-MPC&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Models and solvers are formulated in &lt;code&gt;ros2-workspace/src/adaptive_mpc/tools/omnihex.py&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;acados_generate_code.sh&lt;/code&gt; to generate solver code and do numerical simulation.&lt;/li&gt;
&lt;li&gt;ROS2 Solver node is &lt;code&gt;ros2-workspace/src/adaptive_mpc/src/l1_mpc_main.cpp&lt;/code&gt;. It has to be recompiled after regenerating the solver code (where control params are defined and stored).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;simulation-with-gazebo&#34;&gt;Simulation with Gazebo&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Build ROS2 workspace.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;source /opt/ros/foxy/setup.bash
cd scripts
./build_all_ros_clean.sh
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Build and run PX4 SITL simulation. It is required to source ROS2 setup file.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;source /opt/ros/foxy/setup.bash
source ./ros2-workspace/install/setup.bash
cd PX4-Autopilot
PX4_NO_FOLLOW_MODE=1 make px4_sitl_ctrlalloc gazebo_omni_hex
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Run &lt;code&gt;micrortps_agent&lt;/code&gt; over UDP.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;source /opt/ros/foxy/setup.bash
source ./ros2-workspace/install/setup.bash
micrortps_agent -t UDP
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Use QGC to give commands to the simulation environment. Several useful buttons and modes are listed below.
&lt;ul&gt;
&lt;li&gt;Takeoff and land&lt;/li&gt;
&lt;li&gt;Virtual joysticks&lt;/li&gt;
&lt;li&gt;Position mode, altitude mode, ACRO mode&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Or use the offboard control node to generate a trajectory for omniHex to track.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;source /opt/ros/foxy/setup.bash
source ./ros2-workspace/install/setup.bash
ros2 run px4_ros_com offboard_control
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Above mentioned steps are implemented in &lt;code&gt;run_simulation.sh&lt;/code&gt;, run this script, take off to &lt;code&gt;{0, 0, 2.5}&lt;/code&gt; and run &lt;code&gt;offboard.sh&lt;/code&gt; to track the 8-shape trajectory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;If MPC needed, then take off, use &lt;code&gt;ros2 run trajectory_generator min_ref_publisher 0 0 -2.5 1 0 0 0 0 0 0 0 0 0&lt;/code&gt; to generate a plain state reference, and publish &lt;code&gt;/RunMpc&lt;/code&gt; topic to actually run the MPC. This topic is designed to be published once for a time when you need to change the flag status.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: use service instead&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;real-world-flight&#34;&gt;Real World Flight&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Port connections on NUC:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dynamixel servos on &lt;code&gt;/dev/ttyUSB0 @ 115200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;urtps_bridge on &lt;code&gt;/dev/ttyUSB1 @ 3000000&lt;/code&gt; -&amp;gt; MCU &lt;code&gt;TELEM1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;QGC/mavlink on &lt;code&gt;/dev/ttyACM0 @ any baud&lt;/code&gt; (&lt;code&gt;ACM1&lt;/code&gt; occurs after a reboot) -&amp;gt; MCU &lt;code&gt;microUSB&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;About RC:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;switch A is the kill switch&lt;/li&gt;
&lt;li&gt;switch F sets different flight modes (up: altitude, mid: position, down: acro).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Setup the motion capture system.
&lt;ol&gt;
&lt;li&gt;Open motive software and open the most recent project (Z-up configuration).&lt;/li&gt;
&lt;li&gt;Go to capture layout (upper-right corner) and delete default rigid bodies.&lt;/li&gt;
&lt;li&gt;Aligned markers with the world frame and create a new rigid body from the selected ones, rename this new instance to &lt;code&gt;uav&lt;/code&gt; (as it is fixed in &lt;code&gt;ros1-workspace/src/vrpn_client/launch/default.launch&lt;/code&gt;). Data is automatically published to local network.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Build PX4 firmware.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;source /opt/ros/foxy/setup.bash
cd PX4-Autopilot
make cubepilot_cubeorange_ctrlalloc
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Upload firmware to MCU.
&lt;ol&gt;
&lt;li&gt;Open QGC and navigate to &amp;ldquo;Vehicle Setup-Firmware&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Plug in MCU through USB (ttyACM) port and QGC will auto detect the MCU. This step requires the MCU only powered by USB.&lt;/li&gt;
&lt;li&gt;Select custom firmware and upload &lt;code&gt;PX4-Autopilot/build/cubepilot_cubeorange_ctrlalloc/cubepilot_cubeorange_ctrlalloc.px4&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Restart QGC so that airframe files could be loaded by QGC, then you can do further settings and calibration.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Build ROS1 workspace.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;source /opt/ros/noetic/setup.bash
cd ros1-workspace
catkin build
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Build ROS2 workspace.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;source /opt/ros/foxy/setup.bash
cd scripts
./build_all_ros_clean.sh
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Start packages on NUC: &lt;code&gt;setup_real_flight.sh&lt;/code&gt;. This script starts the following necessary drivers.
&lt;ul&gt;
&lt;li&gt;ROS1 &lt;code&gt;vrpn_client&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ROS2 &lt;code&gt;ros1_bridge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ROS2  &lt;code&gt;micrortps_bridge&lt;/code&gt;, &lt;code&gt;dyanmixel_driver&lt;/code&gt;, &lt;code&gt;optitrack&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Now you can use packages like rqt or rviz for data monitor and visualization. Make sure to source the corresponding ROS version and workspace.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;software-version&#34;&gt;Software Version&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;The original version of &lt;code&gt;PX4&lt;/code&gt; is &lt;code&gt;stable release v1.12.3&lt;/code&gt;. Modified submodules derive from the commit that is referenced by PX4.&lt;/li&gt;
&lt;li&gt;The original version of &lt;code&gt;px4_msg&lt;/code&gt; is commit &lt;code&gt;0f550f436547fccc6b86d448e095ad914f5de94a&lt;/code&gt; on master branch.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;px4_ros_com&lt;/code&gt;: commit &lt;code&gt;c618d757bd64113ccbee17ad0ae17ab8122337e8&lt;/code&gt; on master branch.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;coordinate-frame&#34;&gt;Coordinate Frame&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SDF and Solidworks models
&lt;ul&gt;
&lt;li&gt;front-x, left-y, up-z (body)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PX4
&lt;ul&gt;
&lt;li&gt;NED (world)&lt;/li&gt;
&lt;li&gt;front-x, right-y, down-z (body)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gazebo
&lt;ul&gt;
&lt;li&gt;N-Green-y, E-Red-x, U-Blue-z (world)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Arm rotation: see &lt;a class=&#34;link&#34; href=&#34;https://doi.org/10.3929/ethz-b-000224598&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Control Allocation of a Tilting Rotor Hexacopter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;In SITL, PX4 NED x is aligned with Gazebo y&lt;/li&gt;
&lt;li&gt;In lab setting, PX4 FRD is algined with optitrack x&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sw-model-to-sdf&#34;&gt;SW Model to SDF&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;There are several useful links
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gazebosim.org/tutorials?cat=build_robot&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Gazebo official guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://sdformat.org/spec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Format standard of &lt;code&gt;.sdf&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Do NOT use SW2018SP0&lt;/li&gt;
&lt;li&gt;Minimize the number of links. It is good to treat parts that do not move relatively as a whole. Only separate parts into links if there must be a joint in between. Usually, a link corresponds to an assembly.&lt;/li&gt;
&lt;li&gt;In the assembly that represents a link, make sure to attach a coordinate frame in the SDF convention to the model. This frame will be used as the reference frame when exporting &lt;code&gt;.stl&lt;/code&gt; and calculating mass properties.&lt;/li&gt;
&lt;li&gt;When exporting to &lt;code&gt;.stl&lt;/code&gt; files, hide fine parts otherwise your file would be too big. Choose the aforementioned reference frame, use meter as the scale, and select &amp;ldquo;do not transform to positive space&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Write the SDF
&lt;ul&gt;
&lt;li&gt;SDF uses kilogram and meter as the default unit.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t use mesh as collision. Use the geometry shapes instead.&lt;/li&gt;
&lt;li&gt;Specify a &lt;code&gt;min_depth&lt;/code&gt; property to the collision that is in contact with the ground.&lt;/li&gt;
&lt;li&gt;Use numbers in &amp;ldquo;Moments of inertia, taken at the center of mass and aligned with the output coordinate system&amp;rdquo;. Numbers that are not on the diagonal line of the matrix should be inverted.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sitl_gazebo&lt;/code&gt; plug-ins: &amp;ldquo;IMU&amp;rdquo; should be loaded after &amp;ldquo;mavlink interface&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ros1-packages&#34;&gt;ROS1 Packages&lt;/h2&gt;
&lt;h3 id=&#34;mavros_client&#34;&gt;mavros_client&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;An overlay package for customizing the launch file. Note that this package should not be named &lt;code&gt;mavros&lt;/code&gt;, otherwise ROS may not find the right package path.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vrpn_client&#34;&gt;vrpn_client&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;An overlay package for customizing the launch file.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ros2-packages&#34;&gt;ROS2 Packages&lt;/h2&gt;
&lt;h3 id=&#34;custom_gazebo_plugins&#34;&gt;custom_gazebo_plugins&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;This package is a supplement to &lt;a class=&#34;link&#34; href=&#34;https://github.com/ros-simulation/gazebo_ros_pkgs/tree/foxy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;officially provided ROS2 plug-ins&lt;/a&gt; and those provided in &lt;code&gt;PX4-Autopilot/Tool/sitl_gazebo&lt;/code&gt;. The official repository provides example code for writing a plug-in.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gazebo_ros_arm_rotation.cpp&lt;/code&gt; is for controlling the position of six arm joints of omniHex via the &lt;code&gt;PID&lt;/code&gt; API. Similarly, &lt;code&gt;gazebo_ros_joint_pid_ctrl.cpp&lt;/code&gt; controls the position of a single joint via &lt;code&gt;PID&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gazebo_ros_joint_motor.cpp&lt;/code&gt; is for controlling joint position or velocity via &lt;code&gt;SetParam&lt;/code&gt; and &lt;code&gt;SetPosition&lt;/code&gt; API.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gazebo_ros_motor_model.cpp&lt;/code&gt; is a simplified ROS2 adaptation of the original version in &lt;code&gt;PX4-Autopilot/Tool/sitl_gazebo&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;px4_msgs&#34;&gt;px4_msgs&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;This package contains message types needed by &lt;code&gt;px4_ros_com&lt;/code&gt; and other packages that might use the PX4 types, as well as &lt;code&gt;rqt&lt;/code&gt; utility.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;msg&lt;/code&gt; folder is updated by the script in &lt;code&gt;PX4-Autopilot/msg/tools/uorb_to_ros_msgs.py&lt;/code&gt;. It should be synced whenever a message definition in &lt;code&gt;PX4-Autopilot/msg&lt;/code&gt; is changed.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;px4_ros_com&#34;&gt;px4_ros_com&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The main purpose of this package is to generate the communication bridge &lt;code&gt;micrortps_agent&lt;/code&gt; from a template file &lt;code&gt;src/templates/uorb_rtps_message_ids.yaml&lt;/code&gt;. The template file should be synced with PX4 via script &lt;code&gt;PX4-Autopilot/msg/tools/uorb_to_ros_rtps_ids.yaml&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is also an example of off-board control available in &lt;code&gt;src/examples/offboard&lt;/code&gt;. This example code is modified to generate a full position-pose trajectory as the function of timestamps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;circle&lt;/li&gt;
&lt;li&gt;8-shape&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: use input args or launch file to specify trajectory shape&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It also provides useful scripts for cleaning and building the workspace.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Previously, &lt;code&gt;build_ros2_workspace.bash&lt;/code&gt; is set to skip &lt;code&gt;custom_gazebo_plugins&lt;/code&gt; because the latter depend on &lt;code&gt;px4_msgs&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It is better to add &lt;code&gt;&amp;lt;depend&amp;gt;px4_msg&amp;lt;/depend&amp;gt;&lt;/code&gt; in &lt;code&gt;package.xml&lt;/code&gt;. In this way we don&amp;rsquo;t need to specify a order. Make sure to add &lt;code&gt;find_package(px4_msgs REQUIRED)&lt;/code&gt; and &lt;code&gt;ament_target_dependencies(foo ...px4_msgs...)&lt;/code&gt; in &lt;code&gt;CMakeLists.txt&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;optitrack_driver&#34;&gt;optitrack_driver&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;visual_odom_publisher&lt;/code&gt; receives pose data from MOCAP, performs frame transformation and publishes data to topic &lt;code&gt;VehicleVisualOdometry_PubSubTopic&lt;/code&gt;. In this target, the message is published in a timer callback at 50Hz.&lt;/li&gt;
&lt;li&gt;Timestamps are taken from &lt;code&gt;VehicleImu_PubSubTopic&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callback_relay&lt;/code&gt; is a simple relay. It is similar to &lt;code&gt;visual_odom_publisher&lt;/code&gt; but instead of publishing data in a timer callback, it publishes data in the callback for receiving pose data.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dynamixel_driver&#34;&gt;dynamixel_driver&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;read_write_node&lt;/code&gt; is the example node provided by &lt;code&gt;dynamixel_sdk&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arm_position_control&lt;/code&gt; is the one used for controlling the arm positions. It communicates with dynamixel servos via UART in the callback function for receiving &lt;code&gt;ArmRotation_PubSubTopic&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;trajectory_generator&#34;&gt;trajectory_generator&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;A package for generating trajectories in MPC framework and visualizing &lt;code&gt;TrajectorySetpoint_PubSubTopic&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Visualization is implemented in &lt;code&gt;rviz_translator.cpp&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;adaptive_mpc&#34;&gt;adaptive_mpc&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Input topic: &lt;code&gt;/StateReferenceOcp&lt;/code&gt;, horizon 1s, 20 + 1 nodes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Outputs wrench setpoint&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Switches and flags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/RunMpc&lt;/code&gt;: should be published once every time you wish to change the status of &lt;code&gt;run_mpc_&lt;/code&gt;. It is switched to false if a solver reset has occurred.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;px4-tools-and-miscellaneous&#34;&gt;PX4 Tools and Miscellaneous&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Set the correct URL in &lt;code&gt;.gitmodules&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Custom models for Gazebo simulation is put in &lt;code&gt;PX4-Autopilot/Tools/sitl_gazebo/models&lt;/code&gt; with a corresponding &lt;code&gt;.world&lt;/code&gt; file in &lt;code&gt;PX4-Autopilot/Tools/sitl_gazebo/worlds&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;The initial condition of the simulation could be set in &lt;code&gt;PX4-Autopilot/Tools/sitl_run.sh&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Some plug-ins are built externally (in the ROS2 workspace). So &lt;code&gt;PX4-Autopilot/Tools/setup_gazebo.bash&lt;/code&gt; is modified to export the correct library paths.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;As we are using the &lt;code&gt;micrortps_bridge&lt;/code&gt;, we need to build this module in PX4. We can specify this feature by uncommenting the &lt;code&gt;micrortps_bridge&lt;/code&gt; line in &lt;code&gt;PX4-Autopilot/boards/px4/sitl/ctrlalloc.cmake&lt;/code&gt;, which is the module configuration file for SITL targets. We can choose what modules to be built and what not to be built. The same rule applies to &lt;code&gt;.cmake&lt;/code&gt; files for other boards.&lt;/li&gt;
&lt;li&gt;Add our custom model for gazebo simulation in &lt;code&gt;PX4-Autopilot/platforms/posix/cmake/sitl_target.cmake&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add our airframe file (a model-dependent script for loading parameters and modules) for simulation in &lt;code&gt;PX4-Autopilot/ROMFS/init.d-posix/airframes&lt;/code&gt; and make sure to add this file to the &lt;code&gt;CMakeLists.txt&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The airframe for real hardware is &lt;code&gt;init.d/airframes/6004_omni_hex&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A new mixer is in use: &lt;code&gt;omnihex.main.mix&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mc_rate_control&lt;/code&gt; isn&amp;rsquo;t started in &lt;code&gt;rc.mc_apps&lt;/code&gt; if &lt;code&gt;MIXER = omnihex&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;px4-messages&#34;&gt;PX4 Messages&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Add a message to hold arm positions and limit status: &lt;code&gt;arm_rotation.msg&lt;/code&gt;. After adding a new message file, don&amp;rsquo;t forget to indicate it in &lt;code&gt;CmakeList.txt&lt;/code&gt;, otherwise it won&amp;rsquo;t be compiled.&lt;/li&gt;
&lt;li&gt;Every message should be assigned an ID in &lt;code&gt;msg/tools/urob_rtps_message_ids.yaml&lt;/code&gt; or targets with &lt;code&gt;micrortps_bridge&lt;/code&gt; enabled cannot be compiled. Also, we can specify how &lt;code&gt;micrortps_bridge&lt;/code&gt; treat each message.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vehicle_attitude_setpoint.msg&lt;/code&gt; and &lt;code&gt;vehicle_local_position_setpoint.msg&lt;/code&gt; are modified to handle roll and pitch movements.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;px4-modules&#34;&gt;PX4 Modules&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Generally, a good way to read the code is to look at the header files first. Look at topic subscriptions and publications. Then look at the &lt;code&gt;run()&lt;/code&gt; function in &lt;code&gt;.cpp&lt;/code&gt; files.&lt;/li&gt;
&lt;li&gt;Modified modules are &lt;code&gt;angular_velocity_controller&lt;/code&gt;, &lt;code&gt;commander&lt;/code&gt;, &lt;code&gt;control_allocator&lt;/code&gt;, &lt;code&gt;flight_mode_manager&lt;/code&gt;, &lt;code&gt;mc_att_control&lt;/code&gt; and &lt;code&gt;mc_pos_control&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;angular_velocity_controller&#34;&gt;angular_velocity_controller&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Center of mass compensation $x_{com} \cross F_{sp}$ in &lt;code&gt;AngularVelocityControl.cpp/hpp&lt;/code&gt;, &lt;code&gt;void AngularVelocityControl::update()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read center of mass parameters and call &lt;code&gt;AngularVelocityControl::update()&lt;/code&gt; with additional arguments in&lt;code&gt;AngularVelocityController.cpp/hpp&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Newton-Euler equation cross term $\omega_b \cross v_b$ in &lt;code&gt;void AngularVelocityController::Run()&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Center of mass parameters are defined in &lt;code&gt;vehicle_model_params.c&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;commander&#34;&gt;commander&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;In &lt;code&gt;void Commander::update_control_mode()&lt;/code&gt;, ACRO mode is added with the same set of configuration as POSCTL mode.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;control_allocator&#34;&gt;control_allocator&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;The allocation matrix (actuator effectiveness) is implemented as a subclass of &lt;code&gt;ControlAllocationPseudoInverse&lt;/code&gt; and &lt;code&gt;ModuleParams&lt;/code&gt;. See &lt;code&gt;ActuatorEffectivenessOmniHex.cpp/hpp/params.c&lt;/code&gt; for more detail. In PX4 convention, torque comes above force in a wrench.&lt;/li&gt;
&lt;li&gt;Add omniHex to enum classes, switch cases, and includes in &lt;code&gt;ControlAllocator.cpp/hpp&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Publish control signals to &lt;code&gt;actuator_controls_0&lt;/code&gt; instead of &lt;code&gt;actuator_controls_4&lt;/code&gt;, with &lt;code&gt;actuator_controls_0[3]&lt;/code&gt; reserved for total thrust signal.&lt;/li&gt;
&lt;li&gt;Always check &lt;code&gt;CMakeLists.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flight_mode_manager&#34;&gt;flight_mode_manager&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;This module takes care of controller setpoints in different flight modes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Switch to &lt;code&gt;FlightTaskIndex::ManualAcceleration&lt;/code&gt; when in &lt;code&gt;vehicle_status_s::NAVIGATION_STATE_ACRO&lt;/code&gt;. This feature is implemented in &lt;code&gt;FlightModeManager.cpp&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: exclusive flight task for ACRO mode (not only pitch but full pose)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FlightTask.cpp/hpp&lt;/code&gt;: add missing variables and functions that are not implemented for roll and pitch commands.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FlightTaskManualAltitude.hpp&lt;/code&gt;: add scaling factors from stick to roll and pitch rate.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FlightTaskManualAcceleration.cpp/hpp&lt;/code&gt;: generate different setpoints in different navigation states.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set roll pitch angle and angular speed setpoint in &lt;code&gt;FlightTaskFoo::activate()&lt;/code&gt; function of tasks such as &lt;code&gt;Auto&lt;/code&gt;, &lt;code&gt;Failsafe&lt;/code&gt; and &lt;code&gt;ManualAltitudeSmoothVel&lt;/code&gt;. This is necessary because otherwise the vehicle loses roll and pitch control when auto buttons in QGC is pressed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mc_att_control&#34;&gt;mc_att_control&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;AttitudeControl.cpp&lt;/code&gt;: &lt;code&gt;matrix::Vector3f AttitudeControl::update()&lt;/code&gt; is modified to consider turning rate feed-forward.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AttitudeControl.hpp&lt;/code&gt;: add roll and pitch in &lt;code&gt;void setAttitudeSetpoint()&lt;/code&gt;, also variables.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mc_att_control_main.cpp&lt;/code&gt; and &lt;code&gt;mc_att_control.hpp&lt;/code&gt;: call modified function with the right arguments.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mc_pos_control&#34;&gt;mc_pos_control&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;PositionControl.cpp/hpp&lt;/code&gt;: add variables to take care of roll and pitch rotation. In &lt;code&gt;void PositionControl::getAttitudeSetpoint()&lt;/code&gt; attitude setpoints are passed down and thrust setpoint is converted into body frame.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mc_pos_control_params.c&lt;/code&gt;: define parameters for manual roll and pitch rate control, which are used in &lt;code&gt;FlightTaskManualAltitude.hpp&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MulticopterPositionControl.cpp/hpp&lt;/code&gt;: call modified functions and pass correct arguments.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ekf2&#34;&gt;EKF2&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;In &lt;code&gt;PublishAttitude&lt;/code&gt;, an extra step of converting and publishing RPY is added.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mixer--px4io&#34;&gt;mixer &amp;amp; px4io&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AllocatedActuatorMixer.cpp&lt;/code&gt; now listens to &lt;code&gt;actuator_controls_0&lt;/code&gt; instead of &lt;code&gt;actuator_controls_4&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ESC calibration parts in &lt;code&gt;px4io.cpp&lt;/code&gt; and &lt;code&gt;mixer_module.cpp&lt;/code&gt; are modified for &lt;code&gt;control[0]&lt;/code&gt; to &lt;code&gt;control[6]&lt;/code&gt;, except &lt;code&gt;control[3]&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: test calibration function, &lt;u&gt;&lt;em&gt;&lt;strong&gt;make sure props are removed&lt;/strong&gt;&lt;/em&gt;&lt;/u&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;motor-propeller-model&#34;&gt;Motor-Propeller Model&lt;/h2&gt;
&lt;h3 id=&#34;sitl&#34;&gt;SITL&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;In &lt;code&gt;gazebo_motor_model&lt;/code&gt; and &lt;code&gt;omni_hex.sdf&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;motorConstant = thrustCoef = 8.5e-06&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torqueCoef = thrustCoef * momentConstant = 8.5e-06 * 0.06&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In &lt;code&gt;px4&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;The thrust coefficient if defined as &lt;code&gt;Thrust = CT * u^2&lt;/code&gt;, where u (with value between CA_ACT0_MIN and CA_ACT0_MAX) is the output signal sent to the motor controller. &lt;code&gt;CT = 19.125&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The moment coefficient is defined as Torque = KM * Thrust (is consistent with momentConstant). &lt;code&gt;KM = 0.06&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;From u (PX4) to $\omega$(real rotor angular velocity)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PWM = 1000 * (1 + u)&lt;/code&gt; (observation from print-debugging), where &lt;code&gt;u = actuator_setpoint[0, 1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;omega = (u + offset) * scaling + idle&lt;/code&gt; @(line ~1121 mavlink interface plugin), in sdf &lt;code&gt;offset = 0; scaling = 1500; idle = 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Conversion between &lt;code&gt;CT&lt;/code&gt;(PX4) and &lt;code&gt;motor constant&lt;/code&gt; (thrust coef, paper, plugin), we assume that the idle value is negligable
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CT = scaling^2 * motorConstant&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;real-world-data&#34;&gt;Real World Data&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: mapping between PWM and angular velocity, determine thrust and torque coefficient&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;x = actuator_setpoint[0, 1]&lt;/code&gt; to &lt;code&gt;y = actuator_controls_0[-1, 1]&lt;/code&gt;: $y=2x-1$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x = actuator_controls_0[-1, 1]&lt;/code&gt; to &lt;code&gt;y = PWM[min, max]&lt;/code&gt;: $y=\frac{x(y_{max}-y_{min})}{2}+\frac{y_{max}+y_{min}}{2}$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x = PWM[min, max]&lt;/code&gt; &amp;amp; &lt;code&gt;y = relative_thrust[0, 1]&lt;/code&gt;: $ay^2+(1-a)y-x=0$, where $a\in[0.25,0.35]$&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;matlab-files&#34;&gt;Matlab Files&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;In &lt;code&gt;matlab-workspace&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trajectory.m&lt;/code&gt;: visualization of 8-shape trajectory.&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Dash To Cones</title>
        <link>https://ercbunny.github.io/projects/211113-dashtocones/</link>
        <pubDate>Sat, 13 Nov 2021 16:37:33 +0800</pubDate>
        
        <guid>https://ercbunny.github.io/projects/211113-dashtocones/</guid>
        <description>&lt;img src="https://ercbunny.github.io/projects/211113-dashtocones/cover.png" alt="Featured image of post Dash To Cones" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;video-demo&#34;&gt;VIDEO DEMO&lt;/h2&gt;






    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1E44y1v7D8&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;related-links&#34;&gt;RELATED LINKS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/DashToCones&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Source Code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/DIP-d2c.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;View Project Report PDF (Chinese)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>HLJenga: Hexalink Jenga Manipulator</title>
        <link>https://ercbunny.github.io/projects/210701-hljenga/</link>
        <pubDate>Thu, 01 Jul 2021 15:24:52 +0800</pubDate>
        
        <guid>https://ercbunny.github.io/projects/210701-hljenga/</guid>
        <description>&lt;img src="https://ercbunny.github.io/projects/210701-hljenga/cover.png" alt="Featured image of post HLJenga: Hexalink Jenga Manipulator" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;video-demo&#34;&gt;VIDEO DEMO&lt;/h2&gt;






    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1654y177YU&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;overview&#34;&gt;OVERVIEW&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We were required to program QKM manipulators to play Jenga automatically&lt;/li&gt;
&lt;li&gt;My part was doing hand-eye calibration, blob analysis, path/trajectory planning and simple UI&lt;/li&gt;
&lt;li&gt;The robot operates like this:
&lt;ol&gt;
&lt;li&gt;Take a picture with camera and calculate target positions&lt;/li&gt;
&lt;li&gt;Do path and trajectory planning&lt;/li&gt;
&lt;li&gt;Upload planned trajectory to bot&lt;/li&gt;
&lt;li&gt;Run&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;hand-eye-calibration&#34;&gt;HAND-EYE CALIBRATION&lt;/h2&gt;
&lt;h3 id=&#34;hec-explained-in-a-nutshell&#34;&gt;HEC Explained in A Nutshell&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Aims to find the transform matrix from camera frame to tool frame.&lt;/li&gt;
&lt;li&gt;Intrinsic params: &lt;code&gt;cv::calibrateCamera()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solve for pose of the calibration board in camera frame: &lt;code&gt;cv::solvePnP()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solve for end effector transformation matrix and use &lt;code&gt;cv::calibrateHandEye()&lt;/code&gt; to finish the process&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;solving-the-axxb-problem&#34;&gt;Solving the AX=XB Problem&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://ercbunny.github.io/projects/210701-hljenga/HECProcess.png&#34;
	width=&#34;1066&#34;
	height=&#34;702&#34;
	srcset=&#34;https://ercbunny.github.io/projects/210701-hljenga/HECProcess_huabf55ba5f4cfdf79adad087a67f5cf1d_59423_480x0_resize_box_3.png 480w, https://ercbunny.github.io/projects/210701-hljenga/HECProcess_huabf55ba5f4cfdf79adad087a67f5cf1d_59423_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;HE Calibration Illustrated&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;151&#34;
		data-flex-basis=&#34;364px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consider the transformation $T_{E_1 \rightarrow C_0}=g_{1_1}^{-1}g_{1_0}g_2=g_2g_{3_1}g_{3_0}^{-1}$, where $g$ stands for the configuration of a frame&lt;/li&gt;
&lt;li&gt;By taking N pictures, we can make use of N equations to solve $AX=XB$&lt;/li&gt;
&lt;li&gt;Actual solver is implemented by OpenCV: &lt;code&gt;cv::calibrateHandEye()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Subproblem 1: How to find $g_{3_i }$?
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cv::calibrateCamera()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cv::solvePnP()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Subproblem 2: How to find $g_{1_i }$?
&lt;ul&gt;
&lt;li&gt;Forward kinematics&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ercbunny.github.io/projects/210701-hljenga/subp1.png&#34;
	width=&#34;1908&#34;
	height=&#34;870&#34;
	srcset=&#34;https://ercbunny.github.io/projects/210701-hljenga/subp1_hu76f58b4960776087e81296ab875f36f1_333982_480x0_resize_box_3.png 480w, https://ercbunny.github.io/projects/210701-hljenga/subp1_hu76f58b4960776087e81296ab875f36f1_333982_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Solving Subproblem 1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;219&#34;
		data-flex-basis=&#34;526px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;jenga-detection&#34;&gt;JENGA DETECTION&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Blob Analysis:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RGB to HSV&lt;/li&gt;
&lt;li&gt;Get blob areas based on color filtering&lt;/li&gt;
&lt;li&gt;Apply morphology process to eliminate cracks and dots&lt;/li&gt;
&lt;li&gt;Find blob contours and corresponding &lt;code&gt;minAreaRect&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coordinates transformation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pixel frame to camera frame: $q_{pixel}Z_c=KDq_{camera}$&lt;/li&gt;
&lt;li&gt;Camera frame to world frame: $q_{world}=g_1g_2q_{camera}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sort targets by the distance to base in ascending order, because we need to take into consideration of the height of already built structure and make sure that the planned path does not crush it&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;trajectory-planning&#34;&gt;TRAJECTORY PLANNING&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linear function with parabolic bends and via points
Apply inverse kinematics with given starting, ending and via points to find corresponding points in joint space&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Doing trajectory planning in joint space directly is much faster because of absence of calculating inverse&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To avoid collision and damage, trajectories are first visualized in MATLAB&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ercbunny.github.io/projects/210701-hljenga/traj.png&#34;
	width=&#34;2006&#34;
	height=&#34;522&#34;
	srcset=&#34;https://ercbunny.github.io/projects/210701-hljenga/traj_hu8104c97a1f2c34b96caa86d898114430_93886_480x0_resize_box_3.png 480w, https://ercbunny.github.io/projects/210701-hljenga/traj_hu8104c97a1f2c34b96caa86d898114430_93886_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Trajectory Visualized&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;384&#34;
		data-flex-basis=&#34;922px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;related-links&#34;&gt;RELATED LINKS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/TANGBEN7/HLJenga&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Autonomous Delivery Drone</title>
        <link>https://ercbunny.github.io/projects/210423-delivery/</link>
        <pubDate>Fri, 23 Apr 2021 14:55:42 +0800</pubDate>
        
        <guid>https://ercbunny.github.io/projects/210423-delivery/</guid>
        <description>&lt;img src="https://ercbunny.github.io/projects/210423-delivery/cover.png" alt="Featured image of post Autonomous Delivery Drone" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;video-demo&#34;&gt;VIDEO DEMO&lt;/h2&gt;






    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1AV411J7UV&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;project-overview&#34;&gt;PROJECT OVERVIEW&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Nothing interesting or related to cutting-edge research. Just an engineering level practice&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Some technical approaches:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Localization: optical flow, TOF sensor&lt;/li&gt;
&lt;li&gt;Detection and navigation: YOLO + KCF + Hough Circle Transform on TX2&lt;/li&gt;
&lt;li&gt;Flight controller: ACFLY ADRC&lt;/li&gt;
&lt;li&gt;Communication between FC and TX2: velocity command through serial UART&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;detailed-report&#34;&gt;DETAILED REPORT&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/Autonomous%20Delivery%20Drone%20electric-control%20report.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;View Control and Electronic Circuit Design Scheme PDF (Chinese)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/Autonomous%20Delivery%20Drone%20hardware%20report.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;View Structure Design Scheme PDF (Chinese)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>pyTimelapse</title>
        <link>https://ercbunny.github.io/projects/210122-timelapse/</link>
        <pubDate>Fri, 22 Jan 2021 16:37:33 +0800</pubDate>
        
        <guid>https://ercbunny.github.io/projects/210122-timelapse/</guid>
        <description>&lt;img src="https://ercbunny.github.io/projects/210122-timelapse/cover.jpg" alt="Featured image of post pyTimelapse" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;video-demo&#34;&gt;VIDEO DEMO&lt;/h2&gt;






    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1fA411u7bN&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;







    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1Qq4y1C7kc&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;links&#34;&gt;LINKS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/pyTimelapse&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Open Source Repository&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://1drv.ms/u/s!AtUoQjeuHMpig8JX0S1abcFsuyfjlw?e=GkEuG5&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;strong&gt;Daily Update of Captured Images (Onedrive)&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>A 3-Rotor VTOL UAV</title>
        <link>https://ercbunny.github.io/projects/190815-trivtol/</link>
        <pubDate>Thu, 15 Aug 2019 13:20:21 +0800</pubDate>
        
        <guid>https://ercbunny.github.io/projects/190815-trivtol/</guid>
        <description>&lt;img src="https://ercbunny.github.io/projects/190815-trivtol/cover.png" alt="Featured image of post A 3-Rotor VTOL UAV" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;video-demo&#34;&gt;VIDEO DEMO&lt;/h2&gt;






    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1H4411o7Gq&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;system-overview&#34;&gt;SYSTEM OVERVIEW&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VTOL is achieved by adding a mixing unit to the F4 flight controller running Betaflight Y3 firmware&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The mixing unit takes in PWM outputs of a basic multicopter flight controller and yields signals for VTOL actuators&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We only implemented attitude control. Communication between boards is via PWM&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ercbunny.github.io/projects/190815-trivtol/illustration.png&#34;
	width=&#34;468&#34;
	height=&#34;395&#34;
	srcset=&#34;https://ercbunny.github.io/projects/190815-trivtol/illustration_hu7473972062d87efc5eae662551d8ea8c_78217_480x0_resize_box_3.png 480w, https://ercbunny.github.io/projects/190815-trivtol/illustration_hu7473972062d87efc5eae662551d8ea8c_78217_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Illustration of the UAV | ①: Aileron, ②: Rudder &amp; Elevator, ③ &amp; ④: Tilt Servo, ⑤: Motor&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;118&#34;
		data-flex-basis=&#34;284px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ercbunny.github.io/projects/190815-trivtol/overview.png&#34;
	width=&#34;1312&#34;
	height=&#34;314&#34;
	srcset=&#34;https://ercbunny.github.io/projects/190815-trivtol/overview_hu92f4a20396b16f489f370f9754ddc6b5_153281_480x0_resize_box_3.png 480w, https://ercbunny.github.io/projects/190815-trivtol/overview_hu92f4a20396b16f489f370f9754ddc6b5_153281_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;System Block Diagram&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;417&#34;
		data-flex-basis=&#34;1002px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ercbunny.github.io/projects/190815-trivtol/math.png&#34;
	width=&#34;3840&#34;
	height=&#34;2160&#34;
	srcset=&#34;https://ercbunny.github.io/projects/190815-trivtol/math_hu9284eb0554ec795d5b5d0707c6993e7a_2128860_480x0_resize_box_3.png 480w, https://ercbunny.github.io/projects/190815-trivtol/math_hu9284eb0554ec795d5b5d0707c6993e7a_2128860_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Essential Part of the F1 Mixing Unit Explained&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;detailed-report&#34;&gt;DETAILED REPORT&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/sharedDocs/raw/main/Design%2C%20Control%20and%20Mixing%20of%203-Rotor%20VTOL%20UAVs.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;View PDF (Chinese)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>BunnyAAT</title>
        <link>https://ercbunny.github.io/projects/180914-bunnyaat/</link>
        <pubDate>Fri, 14 Sep 2018 10:19:16 +0800</pubDate>
        
        <guid>https://ercbunny.github.io/projects/180914-bunnyaat/</guid>
        <description>&lt;img src="https://ercbunny.github.io/projects/180914-bunnyaat/cover.png" alt="Featured image of post BunnyAAT" /&gt;&lt;hr&gt;
&lt;h2 id=&#34;video-demo&#34;&gt;VIDEO DEMO&lt;/h2&gt;






    


&lt;div class=&#34;video-wrapper&#34;&gt;
    &lt;iframe src=&#34;https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=2&amp;bvid=BV13W411y77d&#34;
            scrolling=&#34;no&#34;
            frameborder=&#34;no&#34;
            framespacing=&#34;0&#34;
            allowfullscreen=&#34;true&#34;
    &gt;
    &lt;/iframe&gt;
&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;design&#34;&gt;DESIGN&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Please refer to the related links&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;related-links&#34;&gt;RELATED LINKS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://tieba.baidu.com/p/5811562128&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;百度贴吧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ErcBunny/bunnyAAT&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
